## Lab13



### bug



各阶段传回if的tlb指令，没有&&valid，导致一开始无定义

mem传给exe的阻塞信号，没有&&valid

index 的p位不能写









1. a)  CPU 增加 TLBR、TLBWI、TLBP 指令。 
2. b)  CPU 增加 Index、EntryHi、EntryLo0、EntryLo1 寄存器。 
3. c)  CPU 增加 16 项 TLB 结构，支持的页大小为 4KB。 





### TLBR、TLBWI、TLBP 指令



TLBWI 指令完成 TLB 的写操作。它将 EntryHi、EntryLo0 和 EntryLo1 所记录的页表项内容写入 到 TLB 中 Index 寄存器的 Index 域所指的那一项。 

TLBR 指令完成 TLB 的读操作，它将 TLB 中 Index 寄存器的 Index 域所指的那一项的内容读出 来，写入 EntryHi、EntryLo0 和 EntryLo1 寄存器中。 

TLBP 指令完成查询操作。它使用 EntryHi 里的 VPN2 和 ASID 信息去查询 TLB。如果查找到则将该项的索引值写入到 Index 寄存器的 Index 域中，并将 Index 寄存器的 P 域置为 0;否则将 Index 寄 存器的 P 域置为 1。 

- TLBP：
  - 复用访存的 TLB 查找端口并在 EX 级发起查找请求是最合适的 
  - TLBP 指令的待查找内容是来自于 EntryHi 寄存器的，而 这个寄存器会被写回级的 MTC0 指令修改。如果 TLBP 指令在 EX 级的时候，有一条修改 EntryHi 的 MTC0 指令恰好在 MEM 级，那么直接用 CP0 寄存器模块中 EntryHi 寄存器的值就会出问题。这种情 况没有什么好的解决途径，要么阻塞 
- TLBWI  
  -  EntryHi、EntryLo0 和 EntryLo1 寄存器会被写回级 的 MTC0 指令更新，所以让 TLBWI 指令在写回级写 TLB 是合适 ，此时读取的相关 CP0 寄存 器的值都是正确的 
  - 只要发现流水线中存在 TLBWI 指令， 就将该指令后的所有指令标记上一个重取标志。标有重取标志的指令就如同被标记了例外一样，即 它自己不能产生任何执行效果，同时也会阻塞流水线中在它后面的指令产生执行效果 
  - 标有重取标志的指令到达写回流水级后，将像报例外那样清空流水线，但是它并不是真正的例外，所以它不会 修改任何 CP0 寄存器，也不会提升处理器的特权等级，此外 pre-IF 级更新的 nextPC 是标记有重取标 志的指令的 PC，不是任何例外的入口地址。 
- TLBR  
  - TLBR 指令在写回级读 TLB 然后更新相关 CP0 寄存器便是再合适不过了 
  - 由于 TLBR 指令会更新 EntryHi 寄存器的 asid 域，但是所有指令的取指和访存指令 的访存都有可能读取 EntryHi 寄存器的 asid 域去查找 TLB。这意味着 TLBR 指令要像 TLBWI 指令那 样去解决 CP0 冲突问题。解决的方法也自然与 TLBWI 的一样，采用给后续指令标记重取标志的方式。 



CPU 增加 Index、EntryHi、EntryLo0、EntryLo1 寄存器。 

- 我们倾向于将其和已实现的 CP0 放在一个模块中维护 
-  MFC0 和 MTC0 指令访问这几个 CP0 寄存器的数据通路就基本上可 以复用现有的设计 
- 这几个 CP0 寄存器还会被 TLB 指令更新，被 TLB 指令和硬件逻辑读取 







### TLB报例外



miss或无效

控制寄存器 Cause 的 ExcCode 域: 

0x02 (TLBL):取指或读数据 

0x03 (TLBS ):写数据 

修改

控制寄存器 Cause 的 ExcCode 域: 

0x01 (Mod):写数据 

要更新：BadVAddr ：记录触发例外的访问内存的虚地址。 

EntryHi ：VPN2 域更新为 VA31..12 





















os作业第一题





es传向id的valid，似乎只用判断前递和阻塞，就应该使用valid，为什么要用msvalid



上板不过：

brbus也要寄存

——brbus不能只在taken的时候更新，taken是信息，要用的，不是条件，失效后不能一直保持

——且if收到中断时要拉低buf的valid信号（有可能还存着中断时刻id段的跳转，要清一下





clk问题，桥和其他模块的时钟不同

HILO reset置零没上





把input和output写反了，上课还听过，没想到真的发生了，从头到尾都不会报错，warning会说un-driven

按之前讲义上的去检查：有没有input/output接反，有没有reset接错，又没有阻塞非阻塞混用，检查mycpu里的warning。





除了这些，复核有没有使用非握手期间的axi信号。比如在rvalid和rready握手之后，使用了下一拍的rid来做一些事情。









bugs

cpu中的阻塞是readygo信号控制的，在在非valid或者中断的时候，有些阻塞是不必要的

在非valid或者中断的时候，readygo不能阻塞



中断信号从wb段发出，各级被flush，但是if阶段前的一个指令会继续往后流，把各级valid都加上，这是不应该的，这个指令也应该被抹了——保持iftoidvalid在中断未进入前无效：——在exop未拉低前无效——exop在380未进入fs时保持

ws传给if的bus没有保存，又只拉高一拍，导致中断入口没有采入就被覆盖

——中断来了随时更新buf中信息

——但是就因为中断前指令的dataok把if中的内容刷掉然后allowin，进而把buf中其实还没有处理的中断入口刷掉，虽然请求发出去了，处理的都对，但是pc被刷掉了——怎么保护中断入口的pc——还是要保存ws的中断bus





在id阶段不allowin的时候，if阶段的数据保持了，但是fs_to_ds_valid信号没有保持，导致dsallowin升高的时候，遇不到fs valid信号

——如果ds不allowin，则fs不allowin（则instreq拉不起来），且一直保持fs——todsvalid

——还有fs_ready_go——或者直接buf readygo，buf了之后其实不用buf fs to id valid——对，不用了——而且记得readygo拉低条件只用dsallowin，不用fsvalid





- 请求，数据，响应，三个通道的valid和ready信号应该依赖前一次握手成功，否则会有丢失——这个或许可以因为第二个修改后避免：即在拉高条件时严格，保证前一信号进来后就不会在中间拉低，那三个通道的握手信号其实可以同时拉高——还是没有解决，保持了握手信号串行拉高，这样正确，但是很慢
- 不应该拉高awvalid后，又有可能因为后续wait—rdata又拉低，可能导致awready握手信号错过，进而awready不再拉高，一直阻塞

- id与exe中有laod相关的时候，只阻塞一拍，在这一拍mem的前递信号得不到访存值，要等——加一个mem前递阻塞：当msvalid且有前递，且mstowsvalid不为1时，阻塞



读写应该可以实现并行的

- has read的条件应该是地址不相关或没有写任务
- 但是这样又打印不出data，我不知道怎么看波形
- 为什么需要缓存队列？（读写的握手和响应信号是分开的）













## Lab11

### AXI接口

 valid 的置有效一定不能依赖于 ready 是否有效; 

 ready 的置有效可以依赖于 valid 是否有效。 

握手成功的时刻：valid和ready同时为1的第一个clk上升沿



总线事务：

- 一次请求的完整处理（可能包括多次数据返回握手，比如多字节传输）
- =多个总线传输 （总线传输指的是某个通道的一次握手



多通道：

- 读写分开：为了读写并行

读写应该实现并行，事务的响应顺序与请求顺序相同

我们现在实现并行了吗？

- 读写内部多通道：

  - 请求，数据，响应，用于传输不同的数据

  - 用于实现并发：Master 可以连续发出多个请求，哪怕先前发出的 请求所需要的数据还没有传输完毕

    这是不是意味着，请求接收完毕后（不用考虑数据传输是否完成）就可以接收新的请求？



id：标记一个事务，负责请求和响应之间的对应：响应时，只在事务id匹配时才接收

事务不同握手间的依赖

- arvalid 和 arready 都有效之后，Slave 才能将“返回数据”对应的 rvalid 置为有效（通过控制是否“查看”这个rvalid实现：在rvalid的采用条件中加上arvalid 和 arready）
- 只有写请求和写数据的最后一次传输都被 Slave 接收了以后，Slave 才会反馈写响应 









类sram接口

addr_ok 信号是用来和 req 信号一起完成读写请求的握手。只有在 clk 的上升沿同时看到 req 和 addr_ok 都为 1 的时候才是一次成功的请求握手。 

data_ok 信号有双重身份。对应读事务的时候，它是数据返回的有效信号;对应写事务的时候， 它是写响应有效信号。在类 SRAM 接口中，Master 对于响应总是可以接收，所以不再设置响应的握 手信号。你也可以认为存在一个 Master 发给 Slave 的恒为 1 的 data_ack 信号。 



可连续读写：

- 一次读事务未完成的时候，可以发出写事务并执行，只要保证二者的响应握手顺序也按请求顺序就好了

这也需要桥的addrok和dataok能独立响应——

- addrok在可以接收请求的时候拉高
  - ——即使前面请求的data未完成，只要请求握手完成了，就可以接受下一个请求——后来因为请求累积问题哔掉了
  - 最后设计是：啥……不完成前一个data就不拉高？
- dataok在读数据有效/写响应完成时，拉高
  - dataok严格按照事务发起顺序返回



突发传输：可以等实现cache的时候再设计



桥内设计要求：

1. AXI Master 端在发起读请求时，先要确保该请求与“已发出请求但尚未接收到写响应的写请 求”不存在地址相关。最简单粗暴的解决方式是只要有这样的写请求，就停止发起读请求 直至 Master 端收到写响应。 

1. 写后读相关一定通过阻塞读来处理 

2. 类 SRAM 端，如果输入的 req 置为 1 的时候对应的 addr_ok 是 0，那么在 addr_ok 变为 1 之 

   气，要允许输入的所有信号变化，甚至包括 req。 

建议：

1. 为读数据预留缓存，从 rdata 端口上收到的数据先存到这个预留缓存中。 

2. 数据类 SRAM 读请求，优先级固定高于，取指类 SRAM 读请求。 

3. addr_ok 和 data_ok 信号若是来自于组合逻辑，那么这个组合逻辑中 

   不要有 AXI 接口上的 valid 和 ready 输入信号。 





SRAM接口，到类SRAM接口

- 只需要增加 3 个信号:size、addr_ok 和 data_ok
  - size 的生成非常直接 
  - addr_ok 和 data_ok 这两个信号怎么用 ：
  - 取值：
    - pre-IF ：//仅 当 addr_ok 置为 1 的时候，ready_go 才能置为 1
    - IF： //data_ok 返回 1时ready_go 信号才能置为 1。 
    - //如果访存请求被接口响应了，但是指令无法在下一拍进入下一级，那么从下一拍开始不能再发同一个访存请求了
    - //请求一旦置起后，如果没有响应，则不能更换请求 
  - 访存：
  - load
    - //pre-IF 级和 IF 级换成了这里的 EX 级和 MEM级
    - 如果你现在的设计中，MEM 这一级参与前递的有效信号是 MEM 这一级的流水的 valid 信号，那么记得把它调整为 MEM 级进入 WB 级的 ms_to_ws_valid 
  - store
    - //在 EX 级所要做的的改动与 load 类操作一致
      - addrokyou 如下定义：“当操作是写操作时，addr_ok 为 1 表示写地址和写 数据均被接收 ”
    - //MEM 级不需要看 data_ok 信号（看了也没啥



















## Lab9

### 补





代码中标记了“补”字

exe阶段的内存写屏蔽：自己是中断或例外的时候也要屏蔽（目前只用了mem和wb的中断信号）

if reset|cansel， valid=0；

中断，标记，传递，报出



j指令也要拉高bd

——id段发现是分支跳转时，在if阶段拉高bd，并随着bus往后传



体系结构要靠华莱士树（乘法器）



### 例外和中断

例外：软件

中断：硬件

例外代指例外和中断



例外处理是一个软硬件协同的过程，硬件只负责开始和结束的一小部分

- 开始：
  - 触发条件，类型，pc等信息的保存
  - 例外入口跳转
- 结束：pc返回，特权级恢复



### 精确例外：

- 在id/if/exe阶段报出，传回wb阶段处理（更新cp0，修改下一拍pc，阻塞之后的指令）
- 之后的指令完成
- 之后的指令
  - 已进入流水（例外指令到达wb阶段前）：不能：内存，HILO，除法模块
  - 未进入流水：中断指令到达wb阶段后拉低valid信号（wb阶段往前传）（id，exe，mem，wb）



### cp0寄存器：

因为用户态寄存器被保存，内核态处理中断的时候需要用的寄存器

寄存器内部以域为单位管理

#### status

- status im：
  - 软件：mtc0时写，mfc0时读（与regfile的寄存器交互
  - 核内部使用就自由，拉个线就可以
- status exl：
  - 写：reset：0；mtc0（数据通路）；iret（拉低）；任何例外（考虑wb阶段的信号）（拉高）
  - 读：mfc0；核中断逻辑内部使用（可以作为特权级标志，任何需要特权级判断的地方都可以用）
- status ie：
  - 写：reset：0；mtc0
  - 读：mfc0；核中断逻辑

#### cause

- bd：（延迟槽信号）写：reset0；中断且exl=0（更新为流过来的bd）；读：mfc0
- ti：补
  - 写：reset0；count==compare（置1）；mtc0 compare时（置0）；
  - 读：mfc0通路；cause的IP7采样
- IP7～2:
  - 写：复位和中断采样
  - 读：mfc0；核中断逻辑
- IP1～0：写：复位和mtc0；读：mfc0；核中断逻辑
- excode：
  - 写：复位和id阶段的excode
  - 读：mfc0和核逻辑

#### epc

- 写：wb例外+exl非1时：pc/pc-4；mtc0
- 读：mfc0；iret时更新pc

#### BadVAddr

- 写：wb，写入wb_badvaddr（来自if的PC或ls）
- 读：mfc0（要接入mf的通路，加选择条件）

#### count



### cp0数据相关





### 检测逻辑

这七种例外的判定条件请查看附录 D 第 5.1.4 小节至 5.1.9 小节的相关内容 以及 5.2 节的内容 

- 地址错：
  - 取指级： PC 的最低两位断，不是 2’b00 ，地址错例外 (AdEL)
  - EXE级：ls类地址：lw非00|lh非0（AdEL）；sw非00|sh非0（AdES） 
- 整型溢出
  - ADD、ADDI 和 SUB 
  - 对于加法，正数加正数得到负数，或者负数加负数得到正数
  - 对于减法，正数减负数得到负数，或者负数减正数得到正数 
  - 编号？
- 系统调用
  - 译码级识别出 SYSCALL
- 断点
  - 译码级识别出 BREAK
- 保留指令
  - 译码时发现指令码不是任一条指令（所有的inst都为0（？）
- 中断
  - has_int = (Cause.IP[7:0] & Status.IM[7:0])!=8’h00) && Status.IE\==1’b1 && Status.EXL==1’b0; 
  - 时钟中断要自己控制IP和处理更新；IM、IE和EXL要按规范控制（？
  - 中断与指令并无固定关系，希望能通过一套例外的处理框架 ，实现方法为：将**异步的中断事件**动态地标记在某一条指令上（拉高例外信号），随后按例外处理 
  - 通常选择标记在译码级指令上



### 其他

#### 中断：

cause的IP：

7～2，直接采样中断输入引脚（引脚由外部设备拉高）（时钟中断复用IP7）

1～0，软件设置

对应status的IM7～0使能位

还有全局使能位：IE和EXL

中断条件：has_int = (Cause.IP[7:0] & Status.IM[7:0])!=8’h00) && Status.IE\==1’b1 && Status.EXL==1’b0; 

- CPU 并不在意到底接收到的是一个还是多个外部中断。
- 当确实同时接收到多个中断时， 后续的处理交给中断处理函数进行。 



#### 时钟中断（核内控制）

- count和compare
- count：每两个周期++
- 相等时，将 Cause 寄存器的 TI 位置为 1，cause的IP位也采样TI
- TI不可mtc0，compare可，但com写的时候，ti要清零
- 周期控制实现：每次定时中断来时，CompareMFC0 读出，加上 A，再 MTC0 写回（伴随着写回有ti清零



#### 例外入口统一：0xBFC00380  



#### cp0寄存器访问：mfc0，mtc0

- 只能通过通用寄存器运算



#### eret：一步完成中断退出

- epc通过if传出
- Status.EXL 清为  0











































## Lab7

看讲义

设计

添加

仿真：照着讲义来，先跑trace，看ip有没有什么问题，再跑仿真



BGEZ、BGTZ、BLEZ、BLTZ、J、BLTZAL、BGEZAL、JALR 

1. 指令解析，指示变量赋值
2. 数据生成：跳转位，地址位，
3. 控制生成：

（仅涉及译码级）





 LB、LBU、LH、LHU、LWL、LWR、SB、SH、SWL、SWR 

load：数据写回rt

- 根据地址确定内存数据所在位置
- 重复填充+寄存器写使能
- 访存地址的最低两位和访存操作的类型信息——从译码级或
  执行级传递到访存级：需要在数据通路中予以添加
- 写使能：跟内存写使能逻辑差不多
  - 写信号调整为4位，同时修改这部分的前递
  - 不要忘了修改lw的写使能信号



store：数据来自rt

- 根据地址确定寄存器数据所在位置
- 重复填充+写使能
- 复用load的地址和类型通路





- 地址最低两位+指令类型（inst的值（传op就是重复译码））——传至访存级的通路
- 寄存器写使能：
  - 使能信号：后3阶段的前递，id阶段的解析，前递模块间交互
  - 赋值逻辑：
    - Id阶段，根据指令类型和地址后两位（注意lui指令）
    - 每位的拉高逻辑：现今we已拉高+ld指令类型&地址后两位允许
  - reg模块交互/处理逻辑
    - ID处理好的四位传给reg
    - reg根据we更新：用老师给出的逻辑
- store写使能和数据



！先确定数据，再用写使能信号控制写入

！ 写使能是指令类型确定的（load的在id级确定并一直往后传，store的目前是在exe级直接用mem信号拉全了，需要在id阶段加上并一直往后传）

！数据是指令类型+地址后两位确定的：筛选data_sram_rdata获取写回段数据（访存级）（前递的那个），或筛选result（模仿老师的reg更新逻辑）获取传回data_sram_wdata（exe级）





访存地址是在exe获得的，







ID段：

- memwen改为4位，we改为4位，并根据类型赋值——非对其的wen与地址有关
- 新wen往后传，指令类型往后传





只用前递数据的时候，要把传过来的fourwen也传上



地址只有在exe才知道，所以四位wen只有在exe才确定，所以id用的wen和wdata用写回级传回来的

那前递数据呢，需要拼接的呀，32位的赋值分成4个8位赋值，根据wen信号指示更新





sb，sh：取寄存器最低部分，存入对应地址，地址不一定对齐（准备好数据后用写使能控制

lb，lh：取内存地址数据（地址不一定对齐，用选择器选择），扩展后写入寄存器（全写，写使能全开

lwl，lwr：取内存地址数据（全取），写入寄存器，写入不一定是四位（用写使能控制











会不会因为wb数据的一些无效位不同导致仿真不通过？







bug记录：

1. |和||误用：

   内存的四位写使能信号赋值时，不同值之间应该用按位或，但是一开始用成了逻辑或，导致只有最后一位拉高，修改为按位或后bug消除

2. wb的写使能信号修改为4位，因为往外传的时候没有考虑wb阶段的valid，导致即使wb阶段无效的时候，寄存器写使能依然拉高，从而使得一次写入会和trace对比多次，仿真报错

   修改：wen赋值时，加入与wb阶段valid信号的与

3. rs_value的正负判断直接用了运算符（>,>=大等），导致某次跳转判断时出错

   修改：改用“rs_value的最高位”和“rs_value按位或结果是否为零”判断正负

4. load_op赋值时未完全覆盖load指令，还是只用了inst_lw，加上其他load指令后bug消除

5. ”原来这种错误真的有（还以为前几个实验设那么低级的错误是为了坑我们）“系列

   该写lhu写成了lbu，很多控制信号都错过去了……

   swr的数据赋值，”addr偏移为1“这个条件写成了”addr偏移为3“……

   bgezal和bltzal在指令译码时写反了……

   jarl指令译码没解析对……

   还有很多很多：）

   



























## Lab6

如何实现更多的运算类指令。具体包括算术逻辑运算类指令 ADD、ADDI、SUB、SLTI、SLTIU、
ANDI、ORI、XORI、SLLV、SRAV、SRLV，乘除运算类指令 MULT、MULTU、DIV、DIVU，以
及乘除法配套的数据搬运指令 MFHI、MFLO、MTHI、MTLO



1. 了解指令功能
2. 调整数据通路
3. 梳理控制信号



可复用通路：

于是余下的工作就是将这些指令的在各阶段的控制信号按照其所复用数据通路的指令生成出来。



不可复用：

1. ANDI、ORI 和 XORI 

第二个源操作数的产生没有现成的数据通路可以复用，因此需要
对译码阶段的数据通路进行调整，在生成源操作数 2 的多路选择器中添加一个“指令码最低 16 位立
即数零扩展至 32 位”的输入。由于源操作数 2 的多路选择器的规格发生了变化，所以不仅是 ANDI、
ORI 和 XORI，原先已实现的指令都要针对这个更新规格的多路选择器生成正确的控制信号。如果原
先的多路选择器实现是无优先级的，那么建议把新增的输入作为最高的输入;如果原先的多路选择
器实现是有优先级的，那么建议把新增的输入作为非缺省的输入。

2. 调用XilinxIP实现乘除法运算部件

乘：

Vivado 中的综合工具遇到上面代码中的“*”运算符时，就如同它遇到“+”、“>>”运算符时
一样，将根据设计给出的时序等约束情况，从自身的 IP 库中找到一个适合的乘法器电路，然后将其
嵌入到你的设计中

```
wire [31:0] src1, src2;
wire [63:0] unsigned_prod;
wire [63:0] signed_prod;
assign unsigned_prod = src1 * src2;
assign signed_prod   = $signed(src1) * $signed(src2);
//为了实现 MULT 和 MULTU 指令，我们实例化两个乘法器 IP
```

除：

基于交互界面定制除法器 IP



HI/LO 的更新 ：

前面调用乘除法 IP 只是解决了乘除法指令的计算问题，其结果最终还是要写入 HI、LO 寄存器 的。由于所调用的 IP 中，乘法是单周期的，除法是迭代的，所以我们将 HI、LO 寄存器的更新就放 在执行流水阶段完成。



2. 搬运指令添加

四条这样的指令:MFHI 读取 HI 寄存器的值写入到通用寄存器，MFLO 读取 LO
寄存器的值写入到通用寄存器，MTHI 将通用寄存器的值写入到 HI 寄存器，MTLO 将通用寄存器的
值写入到 LO 寄存器

当乘法运算实现为单周期时，意味着乘、除法指令写 HI、LO 寄存器都是在指令位于执行流水 级时进行的。那么很自然的 MTHI 和 MTLO 两条指令也实现为在执行流水级写 HI、LO 寄存器。这 两条指令读取来自通用寄存器的源操作数与 ADDU 等指令读取寄存器源操作数是相似的，所以它们 读通用寄存器堆的数据通路以及源操作数在译码阶段是否就绪的相关判断、数据前递、流水级控制 都可以采用已实现的设计。 

对于 MFHI 和 MFLO 指令来说，它们没有来自于寄存器的源操作数，所以他们不会因为通用寄 存器的写后读相关而被阻塞在译码流水级。又由于所有写 HI、LO 寄存器的动作都是指令位于执行 流水级时完成的，所以这两条指令在位于执行流水级的时候才读取 HI、LO 寄存器自然就能避免因 为 HI、LO 寄存器写后读相关而产生的流水线冲突。在取得 HI、LO 的数值之后，MFHI 和 MFLO 指 令像其它写通用寄存器的指令一样，沿着流水线逐级前行到写回级完成写通用寄存器堆的动作，而 它们在执行、访存、写回三级也可以像 ADDU 之类的指令那样向译码级的指令进行前递。 

















## Lab5

遗留问题：block信号非0即1

不阻塞了是不是就不用改了



### 前递

运算指令：EXE级，访存级和写回级增加前递路径

LW指令：复用运算指令在“访存级和写回级”增加的前递路径



#### 3条前递的始末

EXE：

内容：alu结果

- 起点：（运算）执行级 ALU 的结果输出处/（访存）
- 终点：译码级寄存器堆读出结果生成逻辑处

MEM/WB：

- 起点：MEM结果输出处/写回级将要写入到寄存器堆中的结果
- 终点：译码级寄存器堆读出结果生成逻辑处

#### 译码级MUX

两个端口，逻辑相同

- 输入：寄存器独处结果+3条前递



#### block/readygo信号

readygo置零情况（在目前只实现19条指令的情况下）：

前一条是ld，后一条要写后读，要等一拍，等ld到访存级前递

即：当前访存阶段在读数据，



#### 前递设计改动：

增加了几组连线：

- 3组，epre，mpre，wpre
- 内容：
  - epre：alu结果，esvalid&&we&&(es_dest!=0)，load_op
  - mpre：结果，esvalid&&we&&(es_dest!=0)
  - wpre：结果，esvalid&&we&&(es_dest!=0)



译码级：两个“四选一”：优先级？

- 任一前递采用信号：esvalid&&we&&(es_dest!=0)&&inst_jal&&(es_dest=rs||(es_dest==rt&&dst_is_rt)

  用一个变量信号表示

- 信号优先级：采用前递时：执行>MEM>WB





阻塞逻辑：译码流水级 ready_go 信号的生成逻辑：逻辑？

- 前一条exe不用阻塞，直接从内部逻辑连过来？（希望一拍足够传递

- 当exe阶段是ld指令，且要访存，且写寄存器与译码的读相关，且dst_is_rt

  : esvalid&&we&&(esdeat!=0)&&inst_jal&&(es_dest=rs||(es_dest==rt&&dst_is_rt)

  为什么&inst_jal？

  这节要加一个&&load_op

  然后readygo是～block















## 遗留问题

block信号实际过程中非0即1，readygo信号那里不能用，应该用后几个阶段的valid来

confreg里面即使传了data，wen信号也可能没有拉高，src那里应该没有问题







## Lab4



测试1运行结束后，代码中没有jr ra，所以没有返回，直接+4进入了下面的error循环

应该有jr ra的



有的，就在error里面

你没跳出来，一条执行阶段的相关，往后流3拍后，所有的阶段的寄存器都成了这个地址，已经完成了读取，但是阻塞信号还一直卡着

之前可以解决，是因为遇到的都是exe之后的相关，exe流到后面的时候，addr会被改变，不再相同，解锁

而如果从exe开始相关，一直往后流，一直相同，无法解锁



怎么解决

 一开始以为后面不受影响直接往后流，后来发现其实会阻塞，一拍一拍的往后阻，valid信号会变零

：在valid为0的时候拉低wen



这样不会出现一直阻塞了，能出的来









对数码管更新的值不正确：

就算src不用rdata，有其他人用rdata，所以src那两个判断条件不用要













流水线冲突的阻塞解决

总冲突类型：

- 数据相关
- 控制相关



静态单发射冲突：寄存器写后读

仅处理这一个：



关键点在于译码流水级指令前进还是阻塞的控制条件如何生成

核心是判断处于流水线不同阶段的指令是否存在会引发冲突的“写后读”相关关系

具体描述为:

- 处于译码级的指令：具有来自于非 0 号寄存器的源操作数
- 处于执行级、访存级或写回级的指令：目的操作数的寄存器号（一定非0
- 二者相同



为什么写回级也要考虑：

- 有一个时序特性：写使能有效的时钟周期内，(上升沿采样)，读、写地址若是一样，读端口上只能取出旧值



注意：

1. 判断
   - 判断流水级上到底有无指令：没有指令不用考虑
   - 保证取得的两个操作数有效

2. 阻塞实现
   - 调整译码级的readygo：相关时置0，阻塞流水，等待前面的完成





验收：

运行func_lab4 ，仿真上板

- 还是上次的UCSA_COD，将fun4拷贝到soft下（就是上次的func删了几个nop，可能会有相关）
- cpu132_gettrace生成trace：需要重新定制instram







控制IF阶段的readygo信号：

拉0几个clk：执行3，访存2，写回1

拉0条件：

- 3个分支，分别用于执行，访存，写回阶段的判断
- 判断内容
  - 是否有指令（这怎么判断？没有指令的话指令段是xx啥的？）
  - IF读端的值，后面阶段写端的值，是否非零且相同











































## 笔记

看波形的作业

信号变换和标志线要看上升沿

每个上升沿的行为都取决于上升沿之前的参数



## 作业

lab2：



模块3:

输入：

* switch：4个开关；拨上为1；0～15
* clk，resetn

输出：

* 最左侧数码管，7位：当前片选信号，0～9
* 最右侧4个led灯，4位：上一次片选信号
* 片选信号：8个7位数码管选那哪个









## 体系结构lab3预习：

### 单周期CPU

mips指令系统规范：编程模型，操作模式，指令定义（相关部分），存储管理第一节



CPU：数据通路+控制逻辑

数据通路：多路选择器，时序逻辑器件

控制信号



19条mips指令

数据通路部件：



1. 地址

PC：

2. 虚实地址转换

虚实地址：虚：程序代码中使用，实：cpu和内存使用

虚实地址转换部件：

* TLB-MMU的位置
* 固定映射，以段为单位



3. 物理地址送往内存

RAM：片上RAM作为内存的逻辑代替：输入地址，输出指令

* 异步读
* 实质为内存，所以寻址单位为字节，送过来的物理地址要4位对齐
* 小尾端，指令不需要序调整，可直接输出



指令执行：

定义分析：

需要部件：



运算：加减，或非，大小判断，移位

* regfile：两读一写
* ALU：输入输出
* 移位器：输入输出



多路数据（reg/imm）：多路选择器+条件控制



访存指令：

* 数据ram：输入地址，输出数据，异步读，4对齐





跳转指令：条件，地址，PC修改

* 条件判断逻辑块
* b和jal



模块划分是一个架构思考：复杂，重用，独立，接口清晰



### 分段，流水

流水：不降低吞吐率情况下，增加时频

组合逻辑按功能切分，段间加时序存储

我们采用经典的单发射五级流水：取指译码执行访存写回

regs：

* IF，ID，EXE，MEM，WB，5个reg



缓存内容：

* 有效标志：1位
* 任何被隔断（产生处到使用处）的数据信号和控制信号

同步读ram

指令ram（IF阶段取指）

* 两个周期实现读取：一个周期修改读使能和地址，下一个周期上升沿得到数据
* 如果用同步，IF阶段一眼看去要用两个周期
* 最终采用方案：更新PC阶段发起请求，IF段读出数据
* 所谓“更新PC阶段”：伪流水，没有缓存，组合逻辑输入来自IFID等段的缓存

数据ram：也需要考虑两个时钟周期的问题

* 读写请求于EXE段发出，MEM阶段送达（这时候是不是不用放缓存，可以直接用？）

同步ram的读保持（后续可能会用到）：RAM的Q端会一直保持上次读到的数据，直到下一次有效命令（读使能+变更地址）+上升沿到来



PC逻辑

单周期CPU处理跳转：分两条指令，处理转移指令时，计算出跳转标志及目标地址，保存在触发器中，在处理转移延迟槽指令时，利用存好的信息完成pc更新

流水：设计有点复杂，再看讲义吧

- 由于流水线 CPU 中同一时刻中可能存在多条指令，于是我们就有这样的想法，如果转移延迟槽 

  指令在更新 PC 的时刻，转移指令也在流水线中，那么就可以直接用转移指令的信息来更新 PC，不 用花费额外的存储资源来存储它们了。 

  又因为计算跳转目标地址的信息来自于指令码和通用寄存器堆，所以转移指令若是在 ID 阶段就 能够将这些信息传递给位于 IF 阶段的转移延迟槽指令，那么流水线缓存中就不用花费额外的资源来 存储这些信息了。在不考虑流水线阻塞的情况下，这种设计所假想的情景是显然成立的。但是提前 这里提醒一下各位同学。在 CPU 引入总线之后，指令未必一个时钟周期后就能返回，也就是说，位 于 IF 阶段的转移延迟槽指令可能需要在这一阶段等待多个周期才能进入到 ID 阶段，这个过程中其 对应的转移指令若是不加额外的限制，就有可能完成流水线后续各阶段的处理从而退出流水线了。 于是转移指令所携带的信息到底要不要额外存下来又是一个问题了。我们花了这么多心思就是为了 省一点资源，所以等到引入总线之后又把这些资源加回来会显得很“憋屈”。我们建议的设计方式 是:位于 ID 阶段的转移指令必须等到其对应的转移延迟槽指令可以进入 ID 阶段的时候才能进入到 EXE 阶段。通俗一点来说，就是转移指令必须等到其延迟槽指令取进流水线之后才能进入后续的流 水线阶段。 

- 复位逻辑：给出的参考设计在复位信号有效期间会将 PC 寄存器复位成 0xBFBFFFFC 而不是 MIPS 指令系统
  规范中规定的规定的 0xBFC00000，这只是一个省逻辑的小技巧。由于发给指令 RAM 的请求是来自
  于 pre-IF 阶段的 next_pc 而不是 IF 阶段的 pc，所以这样处理之后，可以在不增加任何新的多路选择
  器逻辑的情况下，使得复位撤销之后第一个发出的取指请求的地址是 0xBFC00000





流水线控制信号设计：

不考虑相关冲突，主要是各级的ready_go信号：暂时恒为1





## Lab3

cpu源码：mycpu_verify/rtl/myCPU



trace对比原理：用正确的cpu运行程序，打印PC与内存读写过程的数据



CPU要在一个系统中发挥作用

我们将采用一个简单的计算机硬件系统。这个硬件系统将通过
FPGA 实验板实现。其核心是在 FPGA 芯片实现的一个片上系统(System On Chip，简称 SoC)。这
个 SoC 芯片通过引脚连接到电路板上的时钟晶振、复位电路，以及 LED 灯、数码管、按键这些外设
接口设备。SoC 芯片内部也是一个小系统，其顶层为 SoC_Lite，

整个 SoC_Lite 的设计都要实现到 FPGA 芯片中，所以在进行综合实现的时
候，你所选择的顶层应该是 soc_lite，不是你自己写的 mycpu。



myCPU设计：

























