

现在处理器就运行在进程 `p` 的内核栈上了。（也就是说cpu的寄存器开始在p的内核栈上调用读取）

：中央处理器（英文CentralProcessingUnit，CPU）是一台计算机的运算核心和控制核心。CPU、内部存储器和输入/输出设备是电子计算机三大核心部件。其功能主要是解释[计算机指令](https://www.baidu.com/s?wd=%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)以及处理计算机软件中的数据。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的CPU的运作原理可分为四个阶段：提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）。 CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。  内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。内存(Memory)也被称为[内存储器](https://www.baidu.com/s?wd=%E5%86%85%E5%AD%98%E5%82%A8%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等[外部存储器](https://www.baidu.com/s?wd=%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来，内存的运行也决定了计算机的稳定运行。 内存是由[内存芯片](https://www.baidu.com/s?wd=%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)、电路板、金手指等部分组成的。 

![image-20180807161732891](/var/folders/xx/ztdttg0x1jl1lhkrxbzhk7rw0000gn/T/abnerworks.Typora/image-20180807161732891.png)





在计算机科学中，**物理地址**（英语：physical address），也叫**实地址**（real address）、**二进制地址**（binary address），它是在[地址总线](https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF/4307936)上，以电子形式存在的，使得[数据总线](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF/272650)可以访问[主存](https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98)的某个特定存储单元的[内存地址](https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80)。

地址从0开始编号，顺序地每次加1，因此存储器的物理[地址空间](https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)是呈线性增长的。它是用[二进制](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457)数来表示的，是[无符号整数](https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0)，书写格式为[十六进制数](https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0)。它是出现在CPU外部[地址总线](https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF)上的寻址[物理内存](https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98)的地址信号，是地址变换的最终结果。用于[内存芯片](https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87)级的单元寻址，与处理器和CPU连接的地址总线相对应。

pc主板？





函数默认是外部的，只要在其他文件中声明就能使用；但是注意如果在前面加上static，就只能在本文件中使用了，不能再被其他的文件调用。



char 的取值范围 -128 - 127 uchar 的取值范围 0 - 255



建立第一个进程的过程：

bios--启动boot loader（boot.s（初始化寄存器，加载GDT，开启保护模式，调为32位，为下面的c程序开一个栈，调用c）--boot.c（加载磁盘上的内核文件，调用内核入口指令，启动entry））

entry是内核的一个指令，是xv6启动后执行的第一个指令

entry会

* 启动页表：建立内存上内核上的物理地址与逻辑地址的映射，设置寄存器等
* 跳转到内核的c代码（main？），在虚拟内存上执行

main会

* 初始化一些设备
* 建立第一个进程（userinit->allocproc）
  * 在页表中分配进程的结构体，初始化进程状态
  * 分配内核栈
* 第一个进程inicode.s的准备
  * 加载到内存中，建立页表
  * trapframe设置为用户模式（？）
  * 初始化完毕后，设置进程状态为runable
  * 调用mpmain-》scheduler运行进程：找到runable，加载页表，设置任务状态段，调状态为running
  * 调用swich，切换上下文到当前进程的内核线程（调整寄存器们：保存当前寄存器，在载入目标线程的寄存器）（然后处理器就运行在当前进程的内核栈上了）
  * ？然后是allocproc，forkret，trapret
  * trapret从trapframe中恢复寄存器，cpu从%eip的值继续执行，这里就是inicode.s的第一条指令
* inicode.s:
  * 触发exec的调用
  * exec会替换成／init





xv6源码分析  linux系统结构宏观了解  深入理解计算机系统

pc架构  硬件结构   操作系统需要了解的抽象结构（哪些寄存器，内存磁盘调用）

操作系统本身的结构（中断管理机制，文件系统）  

操作系统在一个只提供了内存和处理器的硬件上，实现了进程管理系统，文件系统，在这些基础上，硬件／操作系统实现的系统 有了丰富的应用

操作系统可以使用的命令（控制芯片运行），芯片的结构：

精简指令集  复杂指令集

汇编语言，机器语言，转化成电流传递给硬件

汇编：指令，寄存器，地址











扇区



4KB就是2的12次方

扇区是从磁盘读出和写入信息的最小单位，通常大小为512字节

0x1F3 R/W，数据寄存器

0x1F2 R/W，扇区数寄存器，记录操作的扇区数

0x1F3 R/W，扇区号寄存器，记录操作的起始扇区号

0x1F4 R/W，柱面号寄存器，记录柱面号的低 8 位

0x1F5 R/W，柱面号寄存器，记录柱面号的高 8 位

0x1F6 R/W，驱动器/磁头寄存器，记录操作的磁头号，驱动器号，和寻道方式，前 4 位代表逻辑扇区号的高 4 位，DRV = 0/1 代表主/从驱动器，LBA = 0/1 代表 CHS/LBA 方式

0x1F7 R，状态寄存器，第 6、7 位分别代表驱动器准备好，驱动器忙

0x1F8 W，命令寄存器，0x20 命令代表读取扇区









每个运行进程：内存空间（指令，数据（变量），栈（过程），堆），cpu上下文，内核可见的状态

进程空间	系统调用	内核空间

内核	 CPU的硬件保护机制		用户进程只能访问自己的内存空间

实现保护机制所需的		硬件权限(hardware privileges)

系统调用时，硬件会提升特权级。执行一些内核中预定义的功能

（内核就是一些支配硬件的程序吧，跟普通程序没什么本质的区别）





### 进程和内存

内核：一个进程和一个 **pid** (process identifier) 关联起来

xv6 提供了分时特性：CPU 之间切换，等待中的进程		执行

（被执行就是被加载到内存中，创建内存空间，一条条的加载指令==（但是这个过程又是怎么从零开始启动的呢？）==）

一个进程的 CPU 寄存器状态  保存

`fork` 创建一个新的进程		内存内容相同    不同的内存空间和寄存器	改变一个进程中的变量不会影响另一个进程



 `exec`： 某个可执行文件，内存镜像，替换内存空间

xv6 使用 ELF 文件格式

`exec`执行成功后，直接从ELF头中声明的入口开始，执行从文件中加载的指令

`exec` 接受两个参数：可执行文件名和一个字符串参数数组









xv6  	隐式 	分配用户的内存空间		需要额外内存	 `sbrk(n)` 	n 字节	数据内存	返回新内存地址

没有用户概念	更没有不同用户间的保护隔离措施		按照 Unix 的术语来	所有的 xv6 进程都以root 用户执行



### I/O 和文件描述符

一个整数	进程读写	内核管理

进程	获得	：打开文件、目录、设备，创建一个管道（pipe），复制已经存在的文件描述符

文件、管道、设备	抽象	字节流

每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引（？）

进程	文件描述符空间		0读入（标准输入）		1输出（标准输出）	2输出错误（标准错误输出）

 I/O 重定向 		shell	fork，exec			

shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符。==控制台？==

`read` 和 `write` 		文件描述符	文件	读写n字节

`read(fd, buf, n)` 	从 `fd` 	n 个字节	拷贝到 `buf` 中	返回读出字节数

每一个指向文件的文件描述符	都和一个偏移关联



```c
下面这段程序（实际上就是 cat 的本质实现）将数据从标准输入复制到标准输出，如果遇到了错误，它会在标准错误输出输出一条信息。

char buf[512];
int n;

for(;;){
	n = read(0, buf, sizeof buf);
	if(n == 0)
    	break;
    if(n < 0){
        fprintf(2, "read error\n");
		exit();
	}
    if(write(1, buf, n) != n){
    	fprintf(2, "write error\n");
        exit();
	}
}
```



 `close` 		释放	文件描述符		可以被 `open`, `pipe`, `dup` 	重用



新分配的文件描述符		当前进程	最小的	未被使用的	文件描述符

`fork` 会复制父进程的文件描述符和内存

`exec` 会保留它的文件描述符表



```
下面是一个简化版的 shell 执行 cat<input.txt 的代码

char *argv[2];
argv[0] = "cat";
### argv[1] = 0;
if(fork() == 0) {
	close(0);
	open("input.txt", O_RDONLY);
    exec("cat", argv);
}
子进程关闭文件描述符0后，我们可以保证open 会使用0作为新打开的文件 input.txt的文件描述符（怎么保证的？）（因为0是 open 执行时的最小可用文件描述符）（为什么？）。之后 cat 就会在标准输入指向 input.txt 的情况下运行
```

文件偏移   父子进程之间共享  （文件偏移记录在哪？）

`dup`    复制   文件描述符 	共享文件偏移

* `dup` 允许 shell 像这样实现命令：`ls existing-file non-exsiting-file > tmp1 2>&1`. `2>&1` 告诉 shell 给这条命令一个复制描述符1的描述符2。这样 `existing-file` 的名字和 `non-exsiting-file` 的错误输出都将出现在 `tmp1` 中。==为什么是错误输出？ls是什么命令？==

xv6 shell 并未实现标准错误输出的重定向，但现在你知道该怎么去实现它。（怎么实现？标准错误输出还需要重定向？不是直接就开着吗？）



xv6尽量复用了普通操作的代码来建立第一个进程

xv6可以运行在搭载 Intel 80386 及其之后（即"x86"）处理器的 PC 上

许多底层功能（例如虚存的实现）是 x86 处理器专有的



#### 现实情况

UNIX	【“标准”的文件描述符，管道，shell 命令】整合在一起		编写通用、可重用程序		 UNIX 强大和流行的“软件工具”文化	shell脚本语言

UNIX 	系统调用接口	仍然存在于许多操作系统中

现代内核提供了比 xv6 要多得多的系统调用和内核服务

最重要的一点，并不遵循

早期 Unix 	设备暴露为特殊文件		比如控制台文件。

现代基于 Unix 的操作系统	Plan 9 项目		“资源是文件”概念	现代设备	网络、图形和其他资源	文件或者文件树

文件系统抽象	万维网的形式	应用在互联网资源

其他的操作系统接口的模型	Multics		将文件抽象为一种类似内存的概念，产生十分不同的系统接口

xv6 是如何实现类似 Unix 的接口的		复用硬件，进程隔离，进程通讯

## 页表与页表

页表	虚拟地址（x86 指令所使用的地址）	物理地址（处理器芯片向主存发送的地址）

[![figure1-1](https://gitee.com/senjienly/xv6-chinese/raw/master/pic/f1-1.png)](https://gitee.com/senjienly/xv6-chinese/raw/master/pic/f1-1.png)

xv6 为每个进程维护了不同的页表。如图表1-1所示，一片地址空间包含了从虚拟地址0开始的用户内存

用户内存：从低到高，指令，全局变量，栈区，“堆”区   内核区域（0x80100000）

内核的指令和数据

结构体 `struct proc` (2103) 		维护一个进程的众多状态：页表，用户栈，内核栈，当前状态

（ `p->xxx` 来指代 `proc` 结构中的元素）

运行线程	执行进程的指令		挂起  恢复	线程状态（局部变量和函数调用的返回地址）保存在线程的栈上（线程的栈？）

用户栈和内核栈（`p->kstack`）  不／活跃状态    处理器转入xx栈  	提升／硬件的特权级（？）

用户代码无法访问内核栈，只能通过系统调用访问  运行相应的系统调用的代码

线程可以在内核中“阻塞”，等待 I/O, 在 I/O 结束后再恢复运行。

`p->state` 		进程的状态：新建、准备运行、运行、等待 I/O 或退出状态中。

`p->pgdir` 		页表	x86 硬件要求的格式		xv6让	分页硬件	在进程运行时使用 `p->pgdir`     页表还记录了	保存进程内存的物理页的地址（这不是应该的吗……）



Trap Frame是指中断、自陷、异常进入内核后，在堆栈上形成的一种数据结构。



mov es:[bx],[bx]  指令中的两个操作数不能都是寄存器间接寻址





看过这篇之后你应该能想明白为什么 `main` 函数会是 C 语言编写的程序的入口（链接器脚本），可不可以用别的函数做 C 语言编写程序的入口呢？（可以，通过链接器脚本）。

* 因为entry进的main
* 每次建立进程都要进entry吗？





每一个进程（包括普通进程和内核进程）的地址空间都分为用户地址空间和内核地址空间两部分，在32位的x86机器上，用户地址空间的范围是0~3G，内核 地址空间的范围是3G~4G.对于不同的进程，其用户地址空间会随着进程不同而不同，但所有进程的内核地址空间则都是一样的。对于内核进程，由于其始终运 行在内核态，所以没有用户地址空间，其对应的tast_struct结构体中的mm域也就被赋值为NULL。而堆的概念应该是只存在于进程的用户地址空间 中，所以内核进程是没有堆一说的。内核线程可以用kmalloc 或vmalloc在运行时申请内存。kmalloc或vmalloc申请到的内存在整个内核中都可以使用。比方说 内核线程a申请到了一块内存A, 只要把该内存的首地址传给另一个内核线程b，则在b中同样也可以使用这块内存。

 所有进程（包括内核进程和普通进程）都有一个内核栈，在x86的32位机器上内核栈大小可以为4KB或8KB，这个可以在编译内核的时候配置。内核栈的用 途有两个：1）当进程陷入内核态，即内核代表进程执行系统调用时，系统调用的参数就放在内核栈上，内核栈记录着进程的在内核中的调用链；2）在内核栈被配 置成8KB大小的情况下，当中断服务程序中断当前进程时，它将使用当前被中断进程的内核栈。

对于用户进程，其既有用户地址空间中的栈，也有它自己的内核栈。而内核进程就只有内核栈。



### 现实情况

大多操作系统都采用了进程这个概念，而大多的进程都和 xv6 的进程类似。但是==真正的操作系统会利用一个显式的链表在常数时间内找到空闲的 `proc`，而不像 `allocproc` 中那样花费线性时间==；xv6 使用的是朴素的线性搜索（找第一个空闲的 `proc`）。

xv6 的地址空间结构有一个缺点，即无法使用超过 2GB 的物理 RAM。当然我们可以解决这个问题，不过最好的解决方法还是使用64位的机器。

#### 练习

1. 在 `swtch` 中设断点。用 gdb 的 `stepi` 单步调试返回到 `forkret` 的代码，然后使用 gdb 的 `finish` 继续执行到 `trapret`，然后再用 `stepi` 直到你进入虚拟地址0处的 `initicode`。
2. `KERNBASE` 会限制一个进程能使用的内存量，在一台有着 4GB 内存的机器上，这可能会让人感到不悦。那么提高 `KERNBASE`的值是否能让进程使用更多的内存呢？



传统上，把内存视为连续的字节，即内存为字节数组，内存单元的编号（地址）可作为字节数组的索引。 分页管理时，将若干字节视为一页，比如4K byte。此时，内存变成了连续的页，即内存为页数组，每一页物理内存叫页帧，以页为单位对内存进行编号，该编号可作为页数组的索引，又称为页帧号。  页帧和页框是一个东西，英文page frame。

程序运行时，有几个有特定功能的寄存器一直在更新（保存下一条指令的地址，栈区的高低地址等），在函数调用过程中，或者整个执行过程中，这几个寄存器的维护和使用，就代表了栈区的引用与释放











当然作为一款教学为目的的操作系统，xv6 这里的 GDT 设置还是以简单容易理解为目的。诸如“权限位”这样的安全机制就直接被忽略了，而对内存的规划也没有做到真正的“分段”，而是代码段和数据段都启用了从 0 到 4GB 的全部内存寻址。其实这种内存规划方法叫做“平坦内存模型”，即便是 Linux 也是用的这样的方式规划内存的，并没有做到真正的“分段”。这是因为 x86 的分页机制是基于分段的，Linux 选用了更先进的分页机制来管理内存，所以在分段这里只是走一个必要的形式罢了





call bootmain

* 具体会执行什么？call的使用规则是什么？
* 这个指令会导致bootmain.c从bootmain函数开始执行吗？如果不回，那bootmain文件按什么顺序执行？

kernel.ld指明了内核的paddr是0x00100000

kernel.ld是什么？



```
#跳转到内核的 C 代码
  #The indirect call is needed because   （？？？什么是直接跳转？为什么不能？）
  # the assembler produces a PC-relative instruction
  # for a direct jump.
  mov $main, %eax  #就是因为这行，所以c的入口就都是main吗？
  jmp *%eax
```

//* 进程0：Linux引导中创建的第一个进程，完成加载系统后，演变为进程调度、交换及存储管理进程 
//* 进程1：init 进程，由0进程创建（由initcode创建exec加载），完成系统的初始化. 是系统中所有其它用户进程的祖先进程