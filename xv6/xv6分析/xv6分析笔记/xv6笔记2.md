段寄存器的唯一目的就是存放段选择符

选择子确定描述符，描述符确定段基地址，段基地址与偏移之和就是线性地址。所以，虚拟地址空间中的由选择子和偏移两部分构成的二维虚拟地址，就是这样确定了线性地址空间中的一维线性地址。

段选择子长16位，段选择子的高13位是描述符索引(Index)。所谓描述符索引是指描述符在描述符表中的序号。段选择子的第2位是引用描述符表指示位，标记为TI(Table Indicator)，TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。 

段选择器:32位汇编中16位段寄存器(CS、DS、ES、SS、FS、GS)中不再存放段基址,而是段描述符在段描述符表中的索引值,D3-D15位是索引值,D0-D1位是优先级(RPL)用于特权检查,D2位是描述符表引用指示位TI,TI=0指示从全局描述表GDT中读取描述符，TI=1指示从局部描述符中LDT中读取描述符。这些信息总称段选择器(段选择子).

**段描述符**：8个字节64位，每一个段都有一个对应的描述符。根据描述符描述符所描述的对象不同，描述符可分为三类：储存段描述符，系统段描述符，门描述符(控制描述符)。在描述符中定义了段的基址，限长和访问内型等属性。其中基址给出该段的基础地址，用于形成线性地址；限长说明该段的长度，用于存储空间保护；段属性说明该段的访问权限、该段当前在内存中的存在性，以及该段所在的特权级。

段描述符表就是连接段选择子和段描述符的，32位不够了（描述一个保护模式下的段）

当指令给出一个地址后，硬件的处理顺序如下：

1. 根据指令类型选择好段选择符，检查段选择符的TI字段，决定使用GDT还是LDT，再从gftr寄存器或者ldtr寄存器中获得描述符表的地址。
2. 使用段选择符的索引号，定位到段描述符，`描述符地址 = 索引号 * 8 + gdtr(ldtr)中的地址`。
3. 将段描述符中的Base值与给出的地址相加，从而得到线性地址。
4. 将线性地址通过分页单元换换成物理地址。





MMU由一个或一组芯片组成，其功能是把逻辑地址映射为物理地址，即进行地址转换

## MMU地址转化过程

MMU是一种硬件电路，它包含两个部件，一个是分段部件，一个是分页部件，在此，我们把它们分别叫做分段机制和分页机制，以利于从逻辑的角度来理解硬件的实现机制。分段机制把一个逻辑地址转换为线性地址；接着，分页机制把一个线性地址转换为物理地址。

分段机制是IA32提供的寻址方式，这是硬件层面的。就是说，不管你是windows还是linux，只要使用IA32的CPU访问内存，都要经过MMU的转换流程才能得到物理地址，也就是说必须经过逻辑地址–线性地址–物理地址的转换。

## 分段机制的实现

段是虚拟地址空间的基本单位，分段机制必须把虚拟地址空间的一个地址转换为线性地址空间的一个线性地址。

为了实现这种映射，仅仅用段寄存器来确定一个基地址是不够的，至少还得描述段的长度，并且还需要段的一些其他信息，比如访问权之类。所以，这里需要的是一个数据结构，这个结构包括三个方面的内容：

* 段的基地址(Base Address)：在线性地址空间中段的起始地址。
* 段的界限(Limit)：在虚拟地址空间中，段内可以使用的最大偏移量。
* 段的保护属性(Attribute)：表示段的特性。例如，该段是否可被读出或写入，或者该段是否作为一个程序来执行，以及段的特权级等等。  上面的数据结构我们称为段描述符，多个段描述符组成的表称为段描述符表

### 段描述符

所谓描述符(Descriptor)，就是描述段的属性的一个8字节存储单元。在实模式下，段的属性不外乎是代码段、堆栈段、数据段、段的起始地址、段的长度等等，而在保护模式下则复杂一些。IA32将它们结合在一起用一个8字节的数表示，称为描述符 。

![屏幕快照 2018-10-11 下午9.02.10](/Users/caowanlu/Desktop/md%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-11%20%E4%B8%8B%E5%8D%889.02.10.png)

### 段描述符表

各种各样的用户描述符和系统描述符，都放在对应的全局描述符表、局部描述符表和中断描述符表中。描述符表(即段表)定义了IA32系统的所有段的情况。所有的描述符表本身都占据一个字节为8的倍数的存储器空间，空间大小在8个字节(至少含一个描述符)到64K字节(至多含8K)个描述符之间。

* 全局描述符表(GDT)  全局描述符表GDT(Global Descriptor Table)，除了任务门，中断门和陷阱门描述符外，包含着系统中所有任务都共用的那些段的描述符。 它的第一个8字节位置没有使用。
* 中断描述符表IDT(Interrupt Descriptor Table)  中断描述符表IDT(Interrupt Descriptor Table)，包含256个门描述符。IDT中只能包含任务门、中断门和陷阱门描述符，虽然IDT表最长也可以为64K字节，但只能存取2K字节以内的描述符，即256个描述符，这个数字是为了和8086保持兼容。
* 局部描述符表(LDT)  局部描述符表LDT(local Descriptor Table)，包含了与一个给定任务有关的描述符，每个任务各自有一个的LDT。 有了LDT，就可以使给定任务的代码、 数据与别的任务相隔离。每一个任务的局部描述符表LDT本身也用一个描述符来表示，称为LDT描述符，它包含了有关局部描述符表的信息，被放在全局描述符表GDT中。







## xv6（后来总结的）

区分子进程和父进程就是靠fork返回值

子进程的context里面放的是父进程调用fork前的上下文，如果子进程进入调度器，会直接从fork返回的后一步继续执行



文件描述符dup的时候，就是找到对应的文件，占一个新的描述符，然后dup这个文件

一个文件dup的时候，就是加一个ref



inode确实很像一个容器

但是如果需要inode中数据的话，这么弄不会出错吗？



事实上，整个内核就是由各种中断和异常处理程序组成的。





实际上 final address 也只是逻辑地址中的32位偏移量部分，需要使用段选择符找到段描述符，进而得到段基地址，两者相加才是线性地址，但在Linux实现中段基地址都为0，故偏移量可以直接当作线性地址，再经过分页转换就是真正的物理地址，也就是说final address 是程序中访问的地址。



freelist用kalloc分配的是内核偏移后的虚拟地址，在往页表里放的时候会转为物理地址

​    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;        //转成物理地址放入相应的pde









xv6 做得更决绝：允许中断时不能持有任何锁。



什么时候会标记killed？为什么trap要一直检查killed？





idequeue就是一个排队的buf链表



**insl (%dx), %es:(%edi)**

　　这个指令中，%dx中存放着要访问的端口号，0x1f0。该指令的目的就是把端口0x1f0中的数据传输给后面所指向的地址。而后面的地址采用%es:(%edi)格式，其中%edi中存放的就是要被存放的内存空间的起始地址。由于当前计数寄存器%ecx中存放的数值为128，代表我们进行128次存取操作就能读取512byte的扇区。所以每次存取4个字节

回到bootmain后，由于我们这个操作读取出来的数据块是内核的第一个块，里面存放的是内核文件的elf文件头。





日志是记录系统调用的

有没有单独的iderw操作，这时候崩溃了会怎么样？

xv6的系统调用可能是通过地址访问是特权级不够，产生一个类似int的中断跳转





睡眠只发生在了idrew更新buf的时候，进程对buf的访问是不会sleep的，只有在修改buf信息的时候加了几个锁



















