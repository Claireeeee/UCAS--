### BIOS和boot loader的一点背景知识



x86 架构开机引导：从给 x86 通电的一刻开始，CPU 执行的第一段指令是 BIOS 固化在 ROM 上的代码，这个过程是硬件规定的

（具体怎么实现？可能涉及到电路结构问题）

BIOS ：硬件自检完成后（可能会听到“滴”的一声），根据在 BIOS 里设置的启动顺序（硬盘、光驱、USB）读取每个引导设备的第一个扇区 512字节的内容，并判断这段内容的最后 2 字节是否为 0xAA55，如果是说明这个设备是可引导的，将这 512 字节的内容放到内存的 0x7C00 位置，然后告诉 CPU 去执行这个位置的指令（通过设置ip）

加进去的这512字节，是引导加载器	负责内核加载	有两个源文件

* 在磁盘上存储的是编译好的文件，应该是启动前就放好的，吧
* 那怎么在启动前就把编译好的文件移植到磁盘？

### 代码：bootasm.s



bootasm.s和bootmain.c两个文件编译后形成一个代码段bootblock

makefile有说明 bootblock的代码段从 start 处开始执行（可以理解为相当于 C 中的 main 这样的入口函数）。所以 bootasm.S 一上来就是入口 start



 `cli`（8412）屏蔽中断（应该是通过设置的cpu状态）

* bios可能打开了cpu的中断处理
  - 在内核加载之前，cpu就有自己的中断处理程序吗？也是ROM里的？
  - 如果有，为什么要屏蔽，这些程序不能处理bootlock执行中的中断？我启动到一半想停不可以吗？会有什么后果？

接下来的 4 行代码显示用异或将 %ax 寄存器的值置成 0，然后在用 %ax 寄存器的值将 %ds、%es、%ss 三个寄存器的值全部置 0

* 为什么不直接用常数？汇编中可以出现常数吗？
* 感觉需要学一下汇编

* 寻址用得到ax吗？ax也置零必要吗？直接对ds，es，ss异或不可以吗？

这是模拟 Intel 8088 的实模式

配置分段硬件（段寄存器置零），使之不对逻辑地址做任何改变

* cpu寻址中其实隐含地使用了段寄存器的值：取值会用到 %cs，读写数据会用到 %ds，读写栈会用到 %ss

  * 关于段寻址细节，见笔记“段寻址”

* 分段机制对汇编都是隐含的，这是固化到硬件电路里了吧

 .code16 这句。这告诉cpu我们目前是在 16 位模式下执行代码

* 具体怎么告诉的不清楚……



设置0x64 和 0x60上的键盘控制器，使输出端口的第2位置为高位，来使多于20位的地址正常工作

* 虚拟地址 *segment:offset* 可能产生21位物理地址（有这个可能），但 Intel 8088 只能向内存传递20位地址，所以它截断了地址的最高位：0xffff0 + 0xffff = 0x10ffef，但在8088上虚拟地址 0xffff0:0xffff 则是引用物理地址 0x0ffef。
* 因此，早期的软件依赖硬件来忽略多于20位的地址位。当 Intel 研发出使用超过20位物理地址的处理器时，IBM 就想出了一个技巧来保证兼容性。那就是，如果键盘控制器输出端口的第2位是低位，则物理地址的第21位被清零；否则，第21位可以正常使用
* 还有很多其他更高效的方法的（见笔记），xv6用了最简单的而已
* 但是这个端口位置没有其他用处吗？

引导加载器执行 `lgdt`（8441），把指向 `gdt` 的指针 `gdtdesc`（8487-8489）加载到全局描述符表（GDT）寄存器gdtr中

* CPU 单独为我们准备了一个寄存GDTR 用来保存我们 GDT 在内存中的位置和GDT 的长度。GDTR 寄存器一共 48 位，其中高 32 位用来存储GDT 在内存中的位置，其余的低 16 位用来存GDT 有多少个段描述符
* gdtdsec定义在最后，不多不少，正好 48 位传给了 GDTR 寄存器

* gdt已经定义好（在最后）

  * 从宏定义来看，SEG_NULL定义了一个空段（根据习惯，GDT的第一个段都是空段）
  * 可执行的（STA_X）、可读的（STA_R）、基址为0x0且大小为0xffffffff（即占整个PC内存、大小为4GB的）的代码段
  * 可读的（STA_W，取这个值时该段不可执行）、基址为0x0且大小为0xffffffff（同上）的数据段

* 该表是为整个软硬件系统服务的，在进入保护模式之前，必须要定义全局描述符表

  由于在实模式下只能访问1MB的内存，故GDT通常都定义在1MB以下的内存范围中。允许在进入保护模式之后会换个位置重新定义GDT。

引导加载器将 `%cr0` 中的 `CR0_PE` 位置为1，开启保护模式

* （引导加载器让处理器从8088进化到80286，接着进化到了80386）
* 控制寄存器，见“xv6笔记”

更新段选择器：使用了一个 `ljmp` 指令（8453）：跳转到段选择子（gdt中索引）和偏移量指定的代码处

* 长转移指令的功能是：目标地址装入程序计数器PC，使机器执行下一条指令时无条件转移到地址处执行程序，不影响任何标志
* xv6 在这时就准备跳转到用 C 写成的代码处去继续运行了。这个跳转语句的两个参数就是典型的“基地址” + “偏移量”的方式告诉 CPU 要跳转到内存的什么位置去继续执行指令。
* 关于跳转，见“xv6笔记”

SEG_KCODE 是个宏定义，具体的定义在 mmu.h 文件中，翻译过来就是 $(1<<3)，移位，高 13 位刚好是 1，而我们的 GDT 里下标位 1 的内存段正好是“代码段”，而“代码段”在 GDT 的“段描述符”中设置了它的其实内存地址是 0x00000000 ，内存段长度是 0xfffff，这是完整的 4GB 内存。

所以这里的跳转语句选择了“代码段”，由于“代码段”的起始内存地址是 0x00000000 ，长度是完整的 4GB，所以后面的“偏移量”仍然相当于是实际的内存地址，所以这里“偏移量”直接用了 $start32，也就是 start32 直接对应的代码位置。通过这个跳转实际上 CPU 就会跳转到 bootasm.S 文件的 start32 标识符处继续执行了。

start32：初始化保护模式的段寄存器

用相应的段选择子初始化段寄存器

* 还是用ax做中介

选择 0x7c00（在该文件中即 `$start`）作为栈顶（%esp）向下增长

* 为下面的c文件开一个栈

call bootmain

如果bootmain返回：

`bootmain` 的工作就是加载并运行内核。只有在出错时该才会返回

返回后会执行一个死循环（8477-8478）。而一个真正的引导加载器则应该会尝试输出一些调试信息

* 道听途说，其实没看懂
* 如果真是这样，为什么要死循环？



### bootmain.c到init.c



后来感觉一边对着代码一边记笔记，切换窗口不方便，就直接把类似的批注都写到了代码注释里（中文注释是我加的，英文是本来就有的），如有兴趣请往“source files(with annotation)”文件夹查看，里面是我加过注释的文件
