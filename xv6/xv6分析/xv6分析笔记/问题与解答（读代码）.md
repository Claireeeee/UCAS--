## 两个16位表示20位，为什么不用4+16

16+16法：物理地址（physicaladdress）=段值（segment） * 16 + 偏移（offset）

只能表示20位的（因为中间重合的12位，在不同段会有相同的地址出现），而且要求段基质最后4位是0

为什么不直接用映射比较简洁的4+16法？为什么用16+16，很容易有冲突，冲突怎么解决？两个不同的段中找到同一个物理地址，这就不能自如的使用段的虚拟空间，难道最初这个不是为了方便的使用虚拟空间的？只是为了表示20位？而16+16法比16+4法更高效？为什么？

### 相关资料：

真实的段地址有以下的缺点：

1、一个段地址只能指向64K内存(16位偏移的上限)。如果一个程序拥有大于64K的代码那又怎么办呢？在CS里的一个单一的值不能满足整个程序执行的需要。程序必须分成小于64K的段(segment)。当执行从一段移到另一段时，CS里的值必须改变。同样的问题发生在大量的数据和DS 寄存器之间。这样使用是非常不方便的！

2、每个字节在内存里并不只有唯一的段地址。物理地址04808可以表示为：047C:0048，047D:0038，047E:0028 或047B:0058。这将使段地址的比较变得复杂。

## 相对地址访问

“我们编写程序代码，编译器将我们的程序代码变成 CPU 可以理解的指令（二进制可执行程序）。在运行我们写的程序前，需要将程序先加载进内存，而我们的程序应该加载到内存的什么位置这应该是由操作系统来负责的，我们程序本身是不能决定这一切的。

这里就产生了一个“矛盾”。在程序真正运行前我们是不知道我们会被放在内存的什么地方，但是我们的程序本身还有数据，代码也含有对数据的访问（例如我们的代码中使用的各种变量），我们不知道我们的数据会被操作系统放在哪，但我们还要在代码里写访问这些数据的逻辑，这是一个矛盾，要怎么办？”

在c中我们只需要用标示符就好了，是汇编要知道每次引用的数据的地址吧？

## 键盘控制器端口

“如果键盘控制器输出端口（？？？为什么这个方法？这个位置没有其他用处吗？）的第2位是低位，则物理地址的第21位被清零；否则，第21位可以正常使用”

控制 A20 gate 的方法有 3 种：

* 804x 键盘控制器法
* Fast A20 法
* BIOS 中断法

xv6 用了第一种 804x 键盘控制器法，这也是最古老且效率最慢的一种。当然因为硬件的不同，这三种方法可能不会被硬件都支持，正确的做法应该是这三种都尝试一下，每尝试一个就验证一下 A20 gate 是否被正确打开以保证兼容各种硬件。但是 xv6 作为一款教学用的操作系统就没必要做的这么复杂里。只用了一种最古老的方法（保证兼容大多数硬件）而且没有对打开成功与否做验证。像诸如 Linux 这样的操作系统就把三种方法的实现都做好里，并且加上了验证机制。

## 分页 √

cpu接收一个线性地址，经过分页电路结合页表得到物理地址

64位段描述符：保护模式

二级页表  现在只需要有个概念就够了，具体实现有很多种方法，比如二维数组，存储数据块首地址

虚拟vadder也是从0往上生长的吧，所以指的页表不会浪费

GDT是保护模式下段寻址的时候用的，从段描述符中只获得段基址

指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同



内核页表建立（setupkvm）：开一个页，置零，做页目录，PDE全是0，用walkpgdir一个pte一个pte的建（分空间（freelist），映射（修改pte：标志位，物理地址填充）），其中虚拟地址对应的物理地址用kmap指定始末，mappage一个kmap一个kmap的映射（内部用walkpgdir），

然后放入cr3，下次再用va就可以访问到kmap设置好的va了

内核页表：0到phystop全用，映到kernbase之上。在内核态的时候线性和物理用一个kernbase就可以实现了

进程页表：包含内核页表，另外还可以自由映射0到kernbase的虚拟空间使用0到phystop

普通进程的页表建立过程（exec）

setupkvm，建立内核部分映射

elf文件加载到内存

用虚拟地址继续开页

用加到内存上的文件填充页，程序段，完毕

（开栈）开两个页，一个填0，一个作为栈（压参数，pc，参数指针等），完毕

用新开的进程修改“cpu当前进程”结构的参数

然后就进入新建进程了



freelist分配的是虚拟地址  （内核态下减去kernbase就是物理地址）（实际调用看是这样的）

页表frame各小块的存储位置是连续的，frame里面的地址可以随意换

地址++，要看地址类型，按类型单位+

改变CR3来完成页表切换。

程序段应该是包含BSS段，代码段，数据段，堆和栈的

junk要用1，可能是全1很不常见，更容易报错

页表本质是一个unit指针，4字节基址的指针

而且xv6那里限制了1024这个数量：10位索引，不可能超出

为什么要分页？有什么分页的功能是分段实现不了的？

* 既然内存不够那我就增加内存，：把在内存中的程序一些暂时用不到的段交换到硬盘上，腾出空间来，或者干脆等某个进程运行结束后再加载新的进程。而一个段至少也是64kb，这样大的一块空间频繁的从内存和磁盘之间搬来搬去也太慢了吧，IO一般是一个系统的瓶颈。
* 是分段的粒度太大了，分页4kb

一个页目录最多包含1024个页表地址，一个页表有1024个页，为什么要这样设计，因为32位地址的限制？10+10+12是最优的组合方式吗？

“xv6 通过在 `entry` 中使用一个特别的页分配器来解决这个问题。”

* 最早分配的存放页表的空间。汇编代码没看懂

#### freelist的建立

原本应该由`main` 决定有多
少物理内存可⽤于分配，但在 x86 上很难实现。所以它假设机器中有240MB（`PHYSTOP`）物理内存，并将内核末尾和 `PHYSTOP` 之间的内存都作为⼀个初始的空闲内存池。`kinit1`和 `kinit2` 调⽤`freerange`将内存加入空闲链表中，`freerange`则是通过对每⼀页调⽤`kfree` 实现该功能。⼀
个 PTE 只能指向⼀个 4096 字节对齐的物理地址（即是4096 的倍数），因此 `freerange`⽤`PGROUNDUP`来保证分配器只会释放对齐的物理地址。分配器原本⼀开始没有内存可⽤，正是对`kfree` 的调⽤将可⽤内存交给了分配器来管理。

之所以有两个是因为启动时pdt中只存在4MB内存需要使用`kinit1`初始化。后面建立成熟的页表可以访问所有内存后，再调用`kinit2`初始化剩余内存。在调用`kinit1`时并不用锁，也不能锁。因为锁在4MB空间之外。一旦建立好成熟页表后，锁对于保护这个全局链表的安全就相当重要了。



## 硬件寻址

寻址：硬件层面是怎么实现寻址的？地址由谁接收怎么实现ram内定位与访问？

usb接口统一？

单元测试？

计算机网络？  网络是另一个层面的系统了

全局快捷键和应用内部快捷键



## 多核启动

//只有一个mp结构吧？  mp是硬件提供的，还是os设定的？  mp和conf等结构中的域的定义都不清楚

## 只要一个锁就能初始化文件表和进程表？

锁的作用具体体现在哪？kinit1没有用锁照样还是修改了

——锁和文件系统

都什么时候要cli？（xv6哪里用到了cli？）

磁盘上的文件也有inode吗？

## 中断调度这部分

内核页表用的高虚拟地址，一部分放的是内核代码，一部分用作内核栈，其他的呢，还有其他用处吗？

内存上方直接映射的设备区，存放的是什么，是要用于IO映射的？

子程序名还代表子程序第一条指令所在的逻辑地址

睡眠和唤醒实际上就提供了进程间通信的机制

指令产生的中断（int）是要进行特权级检查的：int在获取参数后会检查特权级，检查 CPL <= DPL 使得内核可以禁止一些特权级系统调用。例如，如果用户成功执行了 int 指令，那么 DPL 必须是 3。如果用户程序没有合适的特权级，那么 int 指令就会触发 int 13，这是一个通用保护错误。

“一个程序要在 x86 上进行一个系统调用，它需要调用 int n 指令，这里 n 就是 IDT 的索引”

* 可是除了第一次，我没有在其他系统调用的函数里看到int指令，只有一个call+子进程名  子进程名的值到底是什么啊  压对应的参数并调用int的函数的地址？（我没有在源码里看到这部分代码）调用门直接转入相应的系统调用函数？

call fork，fork的值到底是什么（gdb调试输出看看），是不是它的调用门？还是什么跳转到调用门的地址什么？？？

磁盘的读写和触发中断是ide控制的吗，会自动执行吗？因为idestart只是设置了一下磁盘寄存器，（f7的位置是磁盘状态，现在放成了指令，是不是这样就可以被ide启动了？）

## console

sleep里面

 if(lk == 0)                   //为什么没有锁要panic？
​    panic("sleep without lk");

xv6的panic最后的死循环是怎样一个机制

static void
putc(int fd, char c)
{
  write(fd, &c, 1);        //参数压栈call write，但是我没找到其他文件里的write定义，难道又是调用门？直接转入系统调用？
}







user.h声明了很多函数，但是sys calls那部分我没有找到定义。那怎么办啊











实际用起来发现，xv6没有开发环境，只有几个sh命令，一个构建好的文件系统，一个默默运行的内存分配和进程调度



中断处理：分时，系统调用，panic处理

文件系统：包装好的系统调用，提供很好的磁盘规划

内存管理：分页机制，栈空间的使用

进程调度：sleep，分时

锁：共享数据，原子操作

多处理器

高速缓存管理





保护模式就是

- 在段描述符上加了特权级，类型，和相关的检验机制
- 页类型（读写），可寻址范围限制（比如内核页表映射了所有，用户页表直映射了kernbase之下的va）



## 二刷

xv6 shell 并未实现标准错误输出的重定向，但现在你知道该怎么去实现它。

管道允许同步：每一个读操作都阻塞调用进程，直到另一个进程用 `write` 完成数据的发送

调用进程的当前目录可以通过 `chdir` 这个系统调用进行改变

`mkdir` 创建一个新的目录，`open` 加上 `O_CREATE` 标志打开一个新的文件，`mknod` 创建一个新的设备文件。

这两个设备号唯一确定一个内核设备。当一个进程之后打开这个文件的时候，内核将读、写的系统调用转发到内核设备的实现上，而不是传递给文件系统。

`fstat` 可以获取一个文件描述符指向的文件的信息。它填充一个名为 `stat` 的结构体，

系统调用 `unlink` 从文件系统移除一个文件名。





xv6 关于文件系统的操作都被实现为用户程序，诸如 `mkdir`，`ln`，`rm` 等等，shell只是通过调用执行命令。这种设计允许任何人都可以通过用户命令实现相关功能，比如编写shell脚本

 `cd`，它是在 shell 中实现的

现在看起来这种设计是很显然的，但是 Unix 时代的其他系统的设计都将这样的命令内置在了 shell 中，而 shell 又是内置在内核中的



现代内核提供了比 xv6 要多得多的系统调用和内核服务。

Unix 的作者继续打造Plan 9 项目，它将“资源是文件”的概念应用到现代设备上，将网络、图形和其他资源都视作文件或者文件树。

现代基于 Unix 的操作系统并不遵循早期 Unix 将设备暴露为特殊文件的设计，比如刚才所说的控制台文件。



xv6 使用的是朴素的线性搜索（找第一个空闲的 `proc`）。







RET : CALL   的返回，Pop   IP   from   Stack
RETF: FAR   RET,   Pop   IP   and   CS   from   Stack
IRET: Interrupt   RET,   Pop   IP,   CS   and   Flag   register



这些系统调用都是怎么实现的呀

你要给另一个人讲xv6的话，你要怎么讲明白



控制台文件就是键盘和显示器



x86 支持段式内存转换（见附录 B），但xv6仅用它来实现 `proc` 这种有固定地址，但在不同 CPU 上有不同值的 per-CPU 变量（见 `seginit`）

对于不支持段式内存的体系结构而言，想要实现这种 per-CPU（或 per-thread）的变量，就必须要额外用一个寄存器来保存指向 per-CPU 数据区的指针。由于 x86 的寄存器实在太少，所以花费额外代价用段式内存来实现 per-CPU 变量是值得的。

？？？段式内存？



应该确定实际 RAM 的配置，而不是假设有 240MB 内存。

* 在 x86 上，至少有三个通用算法：第一种是探测物理地址空间，寻找像内存一样能够维持被写入数据的区域；第二种是从 PC 非易失性 RAM 中某个已知的 16-bit 位置处读取内存大小；第三种是在 BIOS 中查看作为多处理器表一部分的内存布局表。读取内存布局表是一项比较复杂的工作。

精巧的内核往往会分配不同大小的内存块，而不是像 xv6 一样固定分配 4096 字节；实际使用的内存分配器必须做到，对小块内存和大块内存的分配请求都能很好地处理。



#### 练习

1. 查看一下真实的操作系统的内存大小。
2. 如果 xv6 没有使用超级页，我们应该如何声明 `entrypgdir`？
3. Unix 在 `exec` 的实现中考虑了对 shell 脚本的特殊处理。执行一个以文本 `#!` 开头的文件时，第一行内容会被系统理解为执行该文件的翻译器。例如，如果用 `exec` 执行 `myprog arg1`，而 `myprog` 的第一行又是 `#!interp`，那么 `exec` 会运行命令 `/interp myprog arg1`。如何 xv6 中实现该功能？



明明只是把esp的值压栈了，然后直接call trap，为什么trap的形参里有tf指针呢？这中间的传递机制？



### 练习

1. 在 `syscall()` 的第一条指令处设置一个断点来截获第一次系统调用（例如 `br syscall`）。此时栈上有一些什么值？解释这个断点下执行 `x/37x $esp` 的输出，对每一个值说明它的含义（如为 trap 保存的 %ebp，trapframe.eip，临时分配空间等等）。
2. 添加一个新的系统调用
3. 添加一个网络驱动



#### 练习

1. 若在 `acquire` 中不用 `xchg`，运行 xv6 会发生什么情况？
2. 把 `iderw` 中的 `acquire` 移到 `sleep` 之前会出现竞争吗？你可以通过运行 xv6 并运行 `stressfs` 来观察。用简单的循环扩大临界区看看会发生什么，并对此作出解释。
3. 完成公布的作业。
4. 在缓冲区的 `flags` 中置位并不是原子操作：处理器会在寄存器中拷贝一份 `flags`，修改寄存器然后写回去。所以两个处理器不能同时写 `flags`。xv6 只在持有 `buflock` 的时候修改 `B_BUSY`，但修改 `B_VALID` 和 `B_WRITE` 的时候并没有锁。为什么这么做仍然是安全的呢？



有一处的 `while` 没有检查 `p->killed`：ide 驱动（3979）直接重新调用了 `sleep`

为什么？？？

之所以可以确保能被唤醒，是因为它在等待一个磁盘中断，如果有第二个进程在中断之前调用了 `iderw`，`ideintr` 会唤醒该进程（第二个），而非原来等待中断的那一个（第一个）进程。第二个进程会认为它收到了它正在等待的数据，但实际上它收到的是第一个进程想要读的数据

（？这一段什么意思？）

#### 练习

1.`sleep` 必须检查 `lk != &ptable.lock` 以避免死锁（2567-2570）。我们可以通过把代码

```
if (lk != &ptable.lock){
    acquire(&ptable.lcok);
    release(lk);
}
```

替换为

```
release(lk);
acquire(&ptable.lock);
```

来避免对特殊情况的判断。这样做会打断 `sleep` 吗？如果会，是在什么情况下？

2.大部分的进程清理工作可以由 `exit` 或 `wait` 完成，但我们在上面看到 `exit` 不能释放 `p->stack`。不过必须由 `exit` 来关闭打开文件。这是为什么？答案会涉及到管道（pipe）。

3.在 xv6 中实现信号量。你可以使用互斥锁，但不能使用睡眠和唤醒。用信号量代替 xv6 中的睡眠和唤醒并评价你的结果。

xv6的日志系统相当不高效

* 不支持并发、可更新的系统调用，即使当系统调用命令在文件系统完全不同的部分间执行
* 要记录整个块，即使一个块只有很少一部分字节改变。
* 可以实现日志记录的同步，但每次只有一个块，每次都可能需要整个磁盘的运转时间
* 现实的日志系统可以处理这些问题



xv6需要文件系统固定在一个磁盘设备上，各个块大小不改变

* 大型数据库和多媒体文件需要更大的储存容量，操作系统需要攻破“一个磁盘一个文件系统”的瓶颈
* （哪里限制了一个文件系统必须放在一个磁盘上？）
* 基础的方法是把许多磁盘联合到一个逻辑磁盘上，硬件解决方案如RAID依旧是最流行的
* 但目前的趋势是在软件上尽可能地实现这种逻辑
* 这种软件的实现可以允许丰富的功能，如通过快速添加和移除命令来实现逻辑设备的增长和缩减（？）
* 当然，存储层的快速增加和减少需要类似机制的文件系统，UNIX文件系统使用的 i 节点块结构是固定空间大小的数组结构，它们不能很好的实现上述功能
* 把文件系统和磁盘管理系统分开也许是最干净的设计，但是两个系统的复杂接口产生了新的系统，如Sun的ZFS，可以把它们联系起来。



xv6文件系统缺少很多现今其他文件系统的特征

* 比如缺乏对“备份的快照和增加”机制的支持（？）

#### 练习

1.为什么在 `balloc` 中会 `panic` ? 我们能恢复吗？

2.为什么在 `ialloc` 中会 `panic` ? 我们能恢复吗？

3.i 节点产生编号

4.为什么当 `filealloc` 用完文件的时候不会 `panic`？为什么这是很普通但是值得处理的？

5.假设 `ip` 对应的文件在 `sys_link` 调用到 `iunlock(ip)` 和 `dirlink` 时被另一个进程去除对应的联系，这个联系还会被正确的创建吗？并说明原因。

6.`create` 有四个函数调用（其中一个是调用到 `ialloc`, 其他三个调用到 `dirlink` ）需要成功创建。如果不能，`create` c产生 `panic` 。为什么这是可取的？为什么这四个调用中的任意一个都不会失败？

7.`sys_chdir` 在调用 `iput(cp->cwd)` 之前调用 `iunlock(ip)`，这个过程可能会锁住 `cp->cwd`，然而推迟 `iunlock(ip)` 调用直到`iput`调用结束，将不会造成死锁，为什么不会？



bootmain

### 练习

1. 基于扇区大小，文中提到的调用 `readseg` 的作用和 `readseg((uchar*)0x100000, 0xb500, 0x1000)` 的作用是相同的。实际上，这个草率的实现并不会导致错误。这是为什么呢？
2. 一些关于 BIOS 存在时长与安全性的问题。
3. 假设你希望 `bootmain()` 能把内核加载到 0x200000 而非 0x100000，于是你在 `bootmain()` 中把每个 ELF 段的 `va` 都加上了 0x100000。这样做是会导致错误发生的，请说明会发生什么错误。
4. 引导加载器把 ELF 头拷贝到了一个随意的地址 0x10000 上，这样做看起来似乎有些危险。那么为什么不调用 `malloc` 来分配它所需要的空间呢？















文件系统，内存管理，进程调度，中断处理

设备驱动，公用的锁



设备驱动：设备的接口，

磁盘：IDE设备（接口设备），通过ide设备访问磁盘

操作系统调用的磁盘参数：设备号，扇区，IRQ，中断，磁盘寄存器

ioapic：

一条APIC总线把"前端"I/O APIC连接到本地APIC。来自[外部设备](https://baike.baidu.com/item/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87)的IRQ线连接到I/O APIC

I/O APIC的组成为: 一组24条IRQ线，一张24项的中断重定向表(Interrupt Redirection Table)，可编程[寄存器](https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8)。通过APIC总线发送和接收APIC信息的一个信息单元，通过中断重定向表把每个外部IRQ信号转换为一条消息，然后通过APIC总线把消息发送给一个或者多个本地APIC单元

系统中最多可拥有 8 个 I/O APIC

操作系统：用一个ioapic结构管理每个apic：给ioapic分配物理地址



xv6只有一个ioapic？只用一个结构就能映射？

































*SDK* 就是 Software Development Kit 的缩写,中文意思就是“软件开发工具包”



文学评论  解读   相关的期刊  著名的文评

和个人理解

自己不一定可以理解所有的感悟，需要别人的阐释



不解释，只有一个分数，自己悟

学术，参考这个领域的想法，作出自己小的贡献



cliche













跟预期不一样的结果不要刻意忽视，要好好的看清楚记清楚，这里面有很多信息可以分析







